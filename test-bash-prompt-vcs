#!/usr/bin/env bash
# Tests for bash-prompt-vcs.bash
#
# Copyright (c) 2016 Marc Meadows
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

# Make sure this code works if it's called when both -e and -u are set.
set -e
set -u

# Test that the prompt outputs what is expected, exiting if not.
# Run once to gather output to test_prompt and then again in the local
# symbol space so we can test_prompt for symbol leakage after all tests have been
# run.
# Output the test description followed by OK. if the prompt output matches
# the expected output or FAILED: and details if not.
# Will make sure the prefix/suffix variables are part of the output.
test_prompt() {
    local -r description="$1"
    local -r expected="$2"
    printf "${description}: "
    local prompt=$(bpvcs_bash_prompt)
    bpvcs_bash_prompt >/dev/null
    if [[ "${prompt}" = "${prefix:-}${expected}${suffix:-}" ]]; then
        printf "OK.\n"
    else
        printf "FAILED.\n  Expected: %q\n       got: %q\n" "${prefix:-}${expected}${suffix:-}" "${prompt}"
        printf "Working trees in ${tmpdir}\n"
        exit
    fi

}

# Tests for non-working tree directories.
test_none() {
    # Need to save/restore suffix so we clobber it for later tests.
    local save_suffix="${suffix}"
    prefix=""
    suffix=""

    cd "${tmpdir}"
    test_prompt "none" ""

    suffix="${save_suffix}"
}

# Tests for git working trees.
run_git() {
    GIT_AUTHOR_NAME="Test BPVCS" \
    GIT_COMMITTER_NAME="Test BPVCS" \
    EMAIL="test-bpvcs@example.com" \
    git "$@" >/dev/null || echo "git run failed"
}

test_git() {
    prefix="${git_prefix}"
    local gitdir=$(mktemp -d --tmpdir=${tmpdir} test_git.XXX)
    cd "${gitdir}"

    run_git init
    test_prompt "git init" "(Initial commit on master|✔)"

    echo "First post!" >first.txt
    run_git add first.txt
    test_prompt "git add" "(Initial commit on master|●1)"

    run_git commit -m first
    test_prompt "git added" "(master|✔)"

    echo "No tracked" >"$gitdir/notme"
    test_prompt "git untracked" "(master|…1)"

    echo "Changed!" >first.txt
    test_prompt "git change" "(master|…1△1)"

    echo "toooooo" >second.txt
    test_prompt "git various" "(master|…2△1)"

    run_git add second.txt
    test_prompt "git staged" "(master|…1△1●1)"

    run_git commit -m "moar files"
    test_prompt "git commit part" "(master|…1△1)"

    echo "spacey" >"spaces in filename.txt"
    test_prompt "git spaces" "(master|…2△1)"
    rm "spaces in filename.txt"

    echo poo >$'\U0001F4A9'
    test_prompt "git unicode" "(master|…2△1)"
    rm $'\U0001F4A9'

    # git tries to track removes so a non-git remove still looks like
    # a delete but the missing.txt is now an untracked file.
    mv second.txt missing.txt
    test_prompt "git missing" "(master|…2△1●1)"
    mv missing.txt second.txt

    run_git mv second.txt 2nd.txt
    test_prompt "git rename" "(master|…1△1●1)"

    run_git commit -a -m "save it all"
    test_prompt "git almost clean" "(master|…1)"

    echo "short lived third" >third.txt
    run_git add third.txt
    run_git commit -m "add third"
    run_git rm third.txt
    test_prompt "git rm" "(master|…1●1)"
    run_git commit -m "we did not want third"

    echo "notme" >"${gitdir}/.gitignore"
    test_prompt "git ignore" "(master|…1)"

    run_git add ".gitignore"
    run_git commit ".gitignore" -m "nothing to see here"
    test_prompt "git faux clean" "(master|✔)"

    rm "${gitdir}/notme"
    test_prompt "git clean" "(master|✔)"

    run_git checkout -b riskychange
    test_prompt "git branch" "(riskychange|✔)"

    run_git checkout master
    test_prompt "git master" "(master|✔)"

    # Replace git with a that outputs nonsense to test parsing errors.
    git() {
        echo "Nonesense"
    }
    prefix="${err_prefix}"
    test_prompt "git bad status" "(unexpected git status output)"

    prefix="${git_prefix}"
    unset git
    test_prompt "git back to good" "(master|✔)"

    # Select a home for the clone but remove it as git clone will create it.
    local gitclonedir=$(mktemp -d --tmpdir=${tmpdir} test_gitclone.XXX)
    rmdir "${gitclonedir}"
    cd "${tmpdir}"
    run_git clone "${gitdir}" "${gitclonedir}"
    cd "${gitclonedir}"
    test_prompt "git clone clean" "(master|✔)"

    # Put clone ahead of remote (original)
    echo "oneoneone" >>first.txt
    run_git commit -a -m "one eleven"
    test_prompt "git clone ahead" "(master⇡|✔)"

    cd "${gitdir}"
    echo "too" >>2nd.txt
    run_git commit -a -m "also"

    cd "${gitclonedir}"
    test_prompt "git clone ahead/behind prefetch" "(master⇡|✔)"
    run_git fetch
    test_prompt "git clone ahead/behind postfetch" "(master⇡⇣|✔)"
}


# Tests for hg working trees.
run_hg() {
    hg --config ui.username=test-bpvcs "$@" >/dev/null || echo "hg run failed"
}

test_hg() {
    prefix="${hg_prefix}"
    local hgdir=$(mktemp -d --tmpdir=$tmpdir test_hg.XXX)
    cd "${hgdir}"

    run_hg init
    test_prompt "hg init" "(default|✔)"

    echo "First post!" >first.txt
    run_hg add first.txt
    test_prompt "hg add" "(default|△1)"

    run_hg commit -m first
    test_prompt "hg added" "(default|✔)"

    echo "No tracked" >"${hgdir}/notme"
    test_prompt "hg untracked" "(default|…1)"

    echo "Changed!" >first.txt
    test_prompt "hg change" "(default|…1△1)"

    echo "toooooo" >second.txt
    test_prompt "hg various" "(default|…2△1)"

    run_hg add second.txt
    test_prompt "hg add second" "(default|…1△2)"

    run_hg commit -m "moar files"
    test_prompt "hg commit" "(default|…1)"

    echo "spacey" >"spaces in filename.txt"
    test_prompt "hg spaces" "(default|…2)"
    rm "spaces in filename.txt"

    echo poo >$'\U0001F4A9'
    test_prompt "hg unicode" "(default|…2)"
    rm $'\U0001F4A9'

    # hg tracks deleted but not removed files, but does not
    # auto-stage them or commit them.  So treat it as an untracked.
    mv second.txt missing.txt
    test_prompt "hg missing" "(default|…3)"
    mv missing.txt second.txt

    run_hg rename second.txt 2nd.txt
    test_prompt "hg rename" "(default|…1△1)"

    run_hg commit -m "save it all"
    test_prompt "hg almost clean" "(default|…1)"

    echo "short lived third" >third.txt
    run_hg add third.txt
    run_hg commit -m "add third"
    run_hg rm third.txt
    test_prompt "hg rm" "(default|…1△1)"
    run_hg commit -m "we did not want third"

    echo "notme" >"${hgdir}/.hgignore"
    test_prompt "hg ignore" "(default|…1)"

    run_hg add ".hgignore"
    run_hg commit ".hgignore" -m "nothing to see here"
    test_prompt "hg faux clean" "(default|✔)"

    rm "${hgdir}/notme"
    test_prompt "hg clean" "(default|✔)"

    run_hg branch riskychange
    test_prompt "hg branch" "(riskychange|✔)"

    run_hg branch --clean
    test_prompt "hg default again" "(default|✔)"

    # Replace hg with a that outputs nonsense to test parsing errors.
    hg() {
        echo "branch: fooled you"
    }
    prefix="${err_prefix}"
    test_prompt "hg bad status" "(unexpected hg summary output)"

    hg() {
        echo "commit: fooledyou"
    }
    test_prompt "hg bad status" "(unexpected hg summary output)"

    prefix="${hg_prefix}"
    unset hg
    test_prompt "hg back to good" "(default|✔)"
}


# Tests for svn sandboxes.
run_svnadmin() {
    svnadmin "$@" >/dev/null || echo "svnadmin run failed"
}

run_svn() {
    svn "$@" >/dev/null || echo "svn run failed"
}

test_svn() {
    prefix="${svn_prefix}"
    local svndir=$(mktemp -d --tmpdir=${tmpdir} test_svn.XXX)
    cd "${svndir}"
    run_svnadmin create SVNROOT

    run_svn checkout "file://${svndir}/SVNROOT" trunk
    cd "trunk"
    test_prompt "svn init" "(✔)"

    echo "First post!" >first.txt
    run_svn add first.txt
    test_prompt "svn add" "(△1)"

    run_svn commit -m first
    test_prompt "svn added" "(✔)"

    echo "No tracked" >"${svndir}/trunk/notme"
    test_prompt "svn untracked" "(…1)"

    echo "Changed!" >first.txt
    test_prompt "svn change" "(…1△1)"

    echo "toooooo" >second.txt
    test_prompt "svn various" "(…2△1)"

    run_svn add second.txt
    test_prompt "svn add second" "(…1△2)"

    run_svn commit -m "moar files"
    test_prompt "svn commit" "(…1)"

    echo "spacey" >"spaces in filename.txt"
    test_prompt "svn spaces" "(…2)"
    rm "spaces in filename.txt"

    echo poo >$'\U0001F4A9'
    test_prompt "svn unicode" "(…2)"
    rm $'\U0001F4A9'

    # Like hg, svn tracks deleted but not removed files, but does not
    # auto-stage them or commit them.  So treat it as an untracked.
    mv second.txt missing.txt
    test_prompt "svn missing" "(…3)"
    mv missing.txt second.txt

    # A rename counts as two changes, an add and a delete
    run_svn rename second.txt 2nd.txt
    test_prompt "svn rename" "(…1△2)"

    run_svn commit -m "save it all"
    test_prompt "svn almost clean" "(…1)"

    echo "short lived third" >third.txt
    run_svn add third.txt
    run_svn commit -m "add third"
    run_svn rm third.txt
    test_prompt "svn rm" "(…1△1)"
    run_svn commit -m "we did not want third"

    run_svn propset svn:ignore "notme" .
    test_prompt "svn ignore" "(△1)"

    # NOTE: The update is needed!
    # See http://subversion.apache.org/faq.html#wc-out-of-date
    run_svn update
    run_svn commit -m "nothing to see here"
    test_prompt "svn faux clean" "(✔)"

    rm "${svndir}/trunk/notme"
    test_prompt "svn clean" "(✔)"

    # Replace svn with a that outputs nonsense to test parsing errors.
    svn() {
        echo "Nonesense"
    }
    prefix="${err_prefix}"
    test_prompt "svn bad status" "(unexpected svn status output)"

    # version numbers below work as of svn 1.8.13
    # http://stackoverflow.com/questions/1364618/how-do-i-determine-the-svn-working-copy-layout-version
    unset svn
    sqlite3 "${svndir}/trunk/.svn/wc.db" "PRAGMA user_version=27"
    test_prompt "svn upgrade needed" "('svn upgrade' needed)"

    prefix="${svn_prefix}"
    sqlite3 "${svndir}/trunk/.svn/wc.db" "PRAGMA user_version=31"
    test_prompt "svn back to good" "(✔)"
}

test_all() {
    test_none && \
    test_git && \
    test_hg && \
    test_svn
}

test_outputs() {
    # Make a home to work in.
    local tmpdir=$(mktemp -d --tmpdir bpvcs-test-XXX)

    # Run through all of the tests with color making sure the output is
    # wrapped correctly with color prefixes and suffixes and that those
    # have the \x01 and \x02 characters that readline requires to recognize
    # non-printing characters.
    local prefix
    local suffix=$(echo     -e "\x01\033[0m\x02")
    local git_prefix=$(echo -e "\x01${BPVCS_GIT_COLOR}\x02 ")
    local hg_prefix=$(echo  -e "\x01${BPVCS_HG_COLOR}\x02 ")
    local svn_prefix=$(echo -e "\x01${BPVCS_SVN_COLOR}\x02 ")
    local err_prefix=$(echo -e "\x01${BPVCS_ERR_COLOR}\x02 ")

    test_all
    echo

    # Run all tests again, this time with colors off and making sure that the
    # non-color prefixes are used.
    echo Testing without colors
    suffix=""
    git_prefix=" git:"
    hg_prefix=" hg:"
    svn_prefix=" svn:"
    err_prefix=" ERR:"
    unset BPVCS_COLORS

    test_all

    # Clean up the temp dir.
    if [[ -n "${tmpdir}" ]]; then
        rm -rf "${tmpdir}"
    fi
}

# Output a list of shell symbols (variables and functions) in a stable order.
# Exclude common "working variables" and this script's specific symbols.
shell_state() {
    (compgen -A variable ; compgen -A function) \
        | grep -v '^PIPESTATUS$' \
        | grep -v '^OLDPWD$' \
        | grep -v '^BASH_REMATCH$' \
        | grep -v '^test_bpvcs_' \
        | sort
}

test_load_and_symbols() {
    echo Testing sourcing and symbols

    # NOTE: Since this test script is run as a separate script, we don't
    # inherit any bash-prompt-vcs symbols even if it's being used on the test
    # host.
    test_bpvcs_before=$(shell_state)

    source bash-prompt-vcs.bash

    test_bpvcs_loaded=$(shell_state)

    test_bpvcs_new_symbols=($(comm -31 <(printf "%s" "${test_bpvcs_before}") \
                                       <(printf "%s" "${test_bpvcs_loaded}")))

    local -i unexpected=0
    local new
    for new in "${test_bpvcs_new_symbols[@]}"; do
        case "${new}" in
              BPVCS_AHEAD_INDICATOR \
            | bpvcs_bash_prompt \
            | BPVCS_BEHIND_INDICATOR \
            | BPVCS_CHANGED_INDICATOR \
            | BPVCS_CLEAN_INDICATOR \
            | BPVCS_COLORS \
            | BPVCS_ERR_COLOR \
            | BPVCS_GIT_COLOR \
            | BPVCS_HG_COLOR \
            | BPVCS_RESET_COLOR \
            | BPVCS_STAGED_INDICATOR \
            | BPVCS_SVN_COLOR \
            | BPVCS_UNTRACKED_INDICATOR \
            | BPVCS_VERSION) ;; # these are all expected, ignore them.
            *) printf "UNEXPECTED: ${new}\n"
               ((++unexpected))
               ;;
        esac
    done

    if [[ ${unexpected} -ne 0 ]]; then
        echo -e "FAILED: ${unexpected} unexpected symbols when loading"
        exit
    fi
}

# Make sure the version being tested matches what we expect and is read-only.
test_version() {
    echo Testing version

    local expected_version="1.0.0"
    if [[ "${BPVCS_VERSION}" != "${expected_version}" ]]; then
        echo "FAILED: BPVCS_VERSION of '${BPVCS_VERSION}' isn't the expected '${expected_version}'"
        exit
    fi

    if [[ ! $(declare -p BPVCS_VERSION) =~ [[:space:]]-r[[:space:]] ]]; then
        echo "FAILED: BPVCS_VERSION is not read-only."
        exit
    fi
}

# Test that the defaults are as expected.
test_defaults() {
    # Confirm these rather than using the variables up above so the tests remain
    # somewhat readable and useful for looking at to see what the code will output.
    echo Testing default indicators
    if [[ "${BPVCS_UNTRACKED_INDICATOR}" != "…" ]]; then echo "FAILED: Wrong default untracked indicator"; exit; fi
    if [[ "${BPVCS_CHANGED_INDICATOR}" != "△" ]];   then echo "FAILED: Wrong default changed indicator";   exit; fi
    if [[ "${BPVCS_STAGED_INDICATOR}" != "●" ]];    then echo "FAILED: Wrong default staged indicator";    exit; fi
    if [[ "${BPVCS_CLEAN_INDICATOR}" != "✔" ]];     then echo "FAILED: Wrong default clean indicator";     exit; fi
    if [[ "${BPVCS_AHEAD_INDICATOR}" != "⇡" ]];     then echo "FAILED: Wrong default ahead indicator";     exit; fi
    if [[ "${BPVCS_BEHIND_INDICATOR}" != "⇣" ]];    then echo "FAILED: Wrong default behind indicator";    exit; fi

    # Make sure we have default colors defined and that we default to using color.
    echo Testing default colors
    if [[ -z "${BPVCS_GIT_COLOR:-}" ]];   then echo "FAILED: No GIT default color!";    exit; fi
    if [[ -z "${BPVCS_HG_COLOR:-}" ]];    then echo "FAILED: No HG default color!";     exit; fi
    if [[ -z "${BPVCS_SVN_COLOR:-}" ]];   then echo "FAILED: No SVN default color!";    exit; fi
    if [[ -z "${BPVCS_RESET_COLOR:-}" ]]; then echo "FAILED: No reset colors default!"; exit; fi
    if [[ -z "${BPVCS_COLORS:-}" ]];      then echo "FAILED: No default color!";        exit; fi
}

test_symbol_leakage() {
    echo Testing symbol leakage after all tests run

    test_bpvcs_after=$(shell_state)

    test_bpvcs_leaked_symbols=$(comm -31 <(printf "%s" "${test_bpvcs_loaded}") \
                                         <(printf "%s" "${test_bpvcs_after}"))

    if [[ -n "${test_bpvcs_leaked_symbols}" ]]; then
        printf "FAILED: Symbols leaked:\n%s\n" "${test_bpvcs_leaked_symbols}"
        exit
    fi
}

main() {
    test_load_and_symbols
    test_version
    test_defaults
    test_outputs
    test_symbol_leakage
    echo
}

main
